= GraphQL Forum

== Features

=== The Stack

Backend::
* `async-graphql`
* Axum
* Tower
* `sqlx`
* SQLite

Frontend::
* Sycamore
* WASM

=== Backend Functionality

* [x] Serves a frontend with the same server
* [x] Backend with tracing
* [x] List topics
* [x] Topic by id
* [x] Create topic
* [x] Create post
* [x] Delete topic
* [x] Delete post

== Frontend Functionality

* [ ] Login page
* [ ] Logout link
* [ ] List topics
* [ ] Topic by id
* [ ] Create topic
* [ ] Create post
* [ ] Delete topic
* [ ] Delete post

=== Authentication

* [x] Sessions
* [x] Password authentication
* [x] Login via username/password
* [x] Registration
* [x] Change password

=== Authorization

* [x] Only admins/author can see deleted topics and posts
* [x] Regular users can see their own posts/topics and any public posts/topics
* [x] Regular users can only delete their own posts
* [x] Admin can delete every post

=== Anti-features

* [x] Horrendous UI design
* [x] Terrible error messages
* [x] `panic!`, `unwrap`, and `expect` everywhere
* [x] Barely any defenses
* [x] Spaghetti code scattered around like crazy
* [x] No documentation
* [x] A test page that does no good except to verify my graphql implementation

== Design Choices

=== N+1

N+1 is not purposefully avoided.
Joins are used to ensure correctness and access control, but not for performance (yet).
See: https://www.sqlite.org/np1queryprob.html.

=== Access Control

Metadata consistency and access control are ensured on SQL queries instead of at application level.
Access control comes in form of 4 views: `topic_permissions`, `topic_public`, `post_permissions`, and `post_public`.

=== Invariants

* Posts are never deleted from database.
* Post number is never changed.
* Post metadata is always accessible, but contents can only be viewed as permitted.

These invariants are enforced by the SQL query used to access posts.

== Experience Report

WARNING: DO NOT IMPLEMENT PASSWORD AUTHENTICATION AND SESSIONS YOURSELF!

=== The Good

* Great performance without even trying
** While I don't have much web experience, the backend feels exceptionally fast
** With `--release`, that is
* Axum comes with a great collection of middleware
* `async-graphql` object definition is relatively easy to use... once I got the basics
* The compiler is very good at catching mistakes, if I am actually using types properly
* Trunk sets up WASM output nicely

=== The Bad

* Really, we are manually doing monadic stack here by using `Context<'_'>`...
* `async-graphql` doesn't work very well with Axum middleware
** Cannot use `CookieJar` because we cannot return extra arguments
*** Ended up rolling my own implementation to sign cookies
** Repetition in binding middleware (in Axum and `async-graphql`)
* `sqlx` generics are extremely hard to check, but I managed to use some anyways
* `sqlx` macros do not work well with SQLite, because it type checks SQLite bytecode at compile time. This has some bugs, and is an extremely slow process
* I have to keep the frontend/backend router in sync, manually.
** For every route the SPA uses, I need the backend to serve the `index.html`
* There aren't any Rust GraphQL clients that work under WASM, so I rolled an extremely simple one in a single file.
* Trunk's proxy doesn't work. It just keeps redirecting until the browser refuses to continue
* Took me an enormous amount of time to figure out how to do async in WASM
* Cargo workspace does not work well with mixed targets
* Sycamore doesn't have very good docs. e.g. how do I bind the username/password variables?