= GraphQL Forum

WARNING: DO NOT even think about using this in production!

== TL;DR

Summarize backend in one line?::
Great performance without even trying, massive pain keeping SQL and code in sync, and huge trouble working around corners of API.

Summarize frontend in one line?::
Surprisingly pleasant to write, but documentation is scarce, and code size is large.

How was the experience?::
Extremely determined. Damn, full-stack is hard.

Will I do this again?::
No, not this stack. If I want to build _anything_ for real, I would go for something like Preact (for frontend) + Hasura (for GQL and data) + Ory Kratos (for auth) + Axum (for business logic).

How is the code quality?::
Probably worth TheDailyWTF kind of quality.

== Features

=== The Stack

Backend::
* `async-graphql`
* Axum
* Tower
* `sqlx`
* SQLite

Frontend::
* Sycamore
* WASM

=== Backend Functionality

* [x] Serves a frontend with the same server
* [x] Backend with tracing
* [x] List topics
* [x] Topic by id
* [x] Create topic
* [x] Create post
* [x] Delete topic
* [x] Delete post

== Frontend Functionality

* [x] Login page
* [x] Logout link
* [ ] List topics
* [ ] Topic by id
* [ ] Create topic
* [ ] Create post
* [ ] Delete topic
* [ ] Delete post

=== Authentication

* [x] Sessions
* [x] Password authentication
* [x] Login via username/password
* [x] Registration
* [x] Change password

=== Authorization

* [x] Only admins/author can see deleted topics and posts
* [x] Regular users can see their own posts/topics and any public posts/topics
* [x] Regular users can only delete their own posts
* [x] Admin can delete every post

=== Anti-features

* [x] Going back after a post crashes the frontend
* [x] Horrendous UI design
* [x] Despite the backend can paginate, you can only see the latest 10 topics on index page
* [x] Despite the backend has this API, you cannot see user profiles
* [x] Terrible error messages
* [x] `panic!`, `unwrap`, and `expect` everywhere
* [x] Error handling scattered across front end, backend, on different layers of `Result`/`Option`, etc.
* [x] Barely any defenses
* [x] No checks what so ever in user input, but injection is guarded against
* [x] Spaghetti code scattered around like crazy
* [x] No documentation
* [x] A test page that does no good except to verify my graphql implementation
* [x] Stale sessions are not cleaned up regularly

== Design Choices

=== N+1

N+1 is not purposefully avoided.
Joins are used to ensure correctness and access control, but not for performance (yet).
See: https://www.sqlite.org/np1queryprob.html.

=== Access Control

Metadata consistency and access control are ensured on SQL queries instead of at application level.
Access control comes in form of 4 views: `topic_permissions`, `topic_public`, `post_permissions`, and `post_public`.

=== Invariants

* Posts are never deleted from database.
* Post number is never changed.
* Post metadata is always accessible, but contents can only be viewed as permitted.

These invariants are enforced by the SQL query used to access posts.

== Experience Report

WARNING: DO NOT IMPLEMENT PASSWORD AUTHENTICATION AND SESSIONS YOURSELF!

=== The Good

* Great performance without even trying
** While I don't have much web experience, the backend feels exceptionally fast
** With `--release`, that is
* Axum comes with a great collection of middleware
* `async-graphql` object definition is relatively easy to use... once I got the basics
* The compiler is very good at catching mistakes, if I am actually using types properly
* Trunk sets up WASM output nicely

=== The Bad

General::
* I have to keep the frontend/backend router in sync, manually.
** For every route the SPA uses, I need the backend to serve the `index.html`
* Cargo workspace does not work well with mixed targets

Backend::
* Really, we are manually doing monadic stack here by using `Context<'_'>`...
* `async-graphql` doesn't work very well with Axum middleware
** Cannot use `CookieJar` because we cannot return extra arguments
*** Ended up rolling my own implementation to sign cookies
** Repetition in binding middleware (in Axum and `async-graphql`)
* `sqlx` generics are extremely hard to check, but I managed to use some anyways
* `sqlx` macros do not work well with SQLite, because it type checks SQLite bytecode at compile time. This has some bugs, and is an extremely slow process

Frontend::
* There aren't any Rust GraphQL clients that work under WASM, so I rolled an extremely simple one in a single file.
* Trunk's proxy doesn't work. It just keeps redirecting until the browser refuses to continue
* Took me an enormous amount of time to figure out how to do async in WASM
* Sycamore doesn't have very good docs. e.g. how do I bind the username/password variables?
* Sycamore macros don't work well with formatting
* Sycamore's routing seems a bit limited
* Cannot figure out how to set status code for Sycamore
* [ ] Wasm is quite large, compared to JS libraries. I have practically all optimization turned to max in this project.